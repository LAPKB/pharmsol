//! PKNCA Cross-Validation Tests
//!
//! This module validates pharmsol's NCA implementation against expected values
//! generated by PKNCA (the gold-standard R package for NCA).
//!
//! The validation uses a clean-room approach:
//! 1. Test scenarios are independently designed based on PK principles
//! 2. PKNCA computes expected values (run `Rscript generate_expected.R`)
//! 3. This module compares pharmsol's results against those expected values
//!
//! Run with: `cargo test pknca_validation`

use pharmsol::nca::{AUCMethod, BLQRule, NCAOptions, Route, RouteParams};
use pharmsol::{prelude::*, Censor};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Tolerance for floating-point comparisons
/// NCA calculations should match within 0.1% for most parameters
const RELATIVE_TOLERANCE: f64 = 0.001;

/// Absolute tolerance for very small values (near zero)
const ABSOLUTE_TOLERANCE: f64 = 1e-10;

// =============================================================================
// JSON Structures for Test Data
// =============================================================================

#[derive(Debug, Deserialize)]
struct TestScenarios {
    scenarios: Vec<Scenario>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct Scenario {
    id: String,
    name: String,
    route: String,
    dose: DoseInfo,
    times: Vec<f64>,
    concentrations: Vec<f64>,
    #[serde(default)]
    auc_method: Option<String>,
    #[serde(default)]
    blq_rule: Option<String>,
    #[serde(default)]
    blq_indices: Option<Vec<usize>>,
    #[serde(default)]
    loq: Option<f64>,
    #[serde(default)]
    partial_auc_interval: Option<Vec<f64>>,
    #[serde(default)]
    tau: Option<f64>,
    test_params: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct DoseInfo {
    amount: f64,
    time: f64,
    #[serde(default)]
    duration: Option<f64>,
}

#[derive(Debug, Deserialize)]
struct ExpectedValues {
    generated_at: String,
    pknca_version: String,
    results: HashMap<String, ScenarioResult>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct ScenarioResult {
    id: String,
    name: String,
    #[serde(default)]
    parameters: HashMap<String, f64>,
    #[serde(default)]
    error: Option<String>,
}

// =============================================================================
// Test Utilities
// =============================================================================

/// Check if two floating-point values are approximately equal
fn approx_eq(a: f64, b: f64, rel_tol: f64, abs_tol: f64) -> bool {
    if a.is_nan() && b.is_nan() {
        return true; // Both NaN is considered equal for our purposes
    }
    if a.is_nan() || b.is_nan() {
        return false;
    }
    if a.is_infinite() && b.is_infinite() {
        return a.signum() == b.signum();
    }
    if a.is_infinite() || b.is_infinite() {
        return false;
    }

    let diff = (a - b).abs();
    let max_val = a.abs().max(b.abs());

    diff <= abs_tol || diff <= rel_tol * max_val
}

/// Map PKNCA parameter names to pharmsol field names
fn map_param_name(pknca_name: &str) -> &str {
    match pknca_name {
        "cmax" => "cmax",
        "tmax" => "tmax",
        "tlast" => "tlast",
        "clast.obs" => "clast",
        "auclast" => "auc_last",
        "aucall" => "auc_all",
        "aumclast" => "aumc_last",
        "aucinf.obs" => "auc_inf_obs",
        "aucinf.pred" => "auc_inf_pred",
        "aumcinf.obs" => "aumc_inf",
        "lambda.z" => "lambda_z",
        "half.life" => "half_life",
        "r.squared" => "r_squared",
        "adj.r.squared" => "adj_r_squared",
        "lambda.z.n.points" => "n_points",
        "span.ratio" => "span_ratio",
        "clast.pred" => "clast_pred",
        "mrt.obs" => "mrt",
        "mrt.iv.obs" => "mrt_iv",
        "tlag" => "tlag",
        "c0" => "c0",
        "cl.obs" => "cl",
        "vd.obs" => "vd",
        "vz.obs" => "vz",
        "vss.obs" => "vss",
        "auc_extrap_pct" => "auc_pct_extrap",
        "cmin" => "cmin",
        "cav" => "cavg",
        "auc_tau" => "auc_tau",
        "fluctuation" => "fluctuation",
        "swing" => "swing",
        _ => pknca_name,
    }
}

/// Convert scenario route string to pharmsol Route
#[allow(dead_code)]
fn parse_route(route: &str) -> Route {
    match route {
        "iv_bolus" => Route::IVBolus,
        "iv_infusion" => Route::IVInfusion,
        _ => Route::Extravascular,
    }
}

/// Convert AUC method string to pharmsol AUCMethod
fn parse_auc_method(method: Option<&str>) -> AUCMethod {
    match method {
        Some("linear") => AUCMethod::Linear,
        Some("lin-log") => AUCMethod::LinLog,
        _ => AUCMethod::LinUpLogDown,
    }
}

/// Convert BLQ rule string to pharmsol BLQRule
fn parse_blq_rule(rule: Option<&str>) -> BLQRule {
    match rule {
        Some("zero") => BLQRule::Zero,
        Some("loq_over_2") => BLQRule::LoqOver2,
        Some("positional") => BLQRule::Positional,
        _ => BLQRule::Exclude,
    }
}

// =============================================================================
// Main Validation Function
// =============================================================================

/// Run validation for a single scenario
fn validate_scenario(
    scenario: &Scenario,
    expected: &ScenarioResult,
) -> Result<Vec<(String, f64, f64, bool)>, String> {
    // Skip if PKNCA had an error
    if let Some(err) = &expected.error {
        return Err(format!("PKNCA error: {}", err));
    }

    // Build pharmsol Subject
    let mut builder = Subject::builder(&scenario.id);

    // Add dose based on route
    match scenario.route.as_str() {
        "iv_bolus" => {
            builder = builder.bolus(scenario.dose.time, scenario.dose.amount, 0);
        }
        "iv_infusion" => {
            let duration = scenario.dose.duration.unwrap_or(1.0);
            builder = builder.infusion(scenario.dose.time, scenario.dose.amount, 0, duration);
        }
        _ => {
            builder = builder.bolus(scenario.dose.time, scenario.dose.amount, 0);
        }
    }

    // Add observations
    let loq = scenario.loq.unwrap_or(0.1);
    let blq_indices: Vec<usize> = scenario.blq_indices.clone().unwrap_or_default();

    for (i, (&time, &conc)) in scenario
        .times
        .iter()
        .zip(&scenario.concentrations)
        .enumerate()
    {
        if blq_indices.contains(&i) {
            builder = builder.censored_observation(time, loq, 0, Censor::BLOQ);
        } else {
            builder = builder.observation(time, conc, 0);
        }
    }

    let subject = builder.build();

    // Configure NCA options
    let mut options = NCAOptions::default()
        .with_auc_method(parse_auc_method(scenario.auc_method.as_deref()))
        .with_blq_rule(parse_blq_rule(scenario.blq_rule.as_deref()));

    if let Some(interval) = &scenario.partial_auc_interval {
        if interval.len() == 2 {
            options = options.with_auc_interval(interval[0], interval[1]);
        }
    }

    // Add tau for steady-state analysis
    if let Some(tau) = scenario.tau {
        options = options.with_tau(tau);
    }

    // Run NCA
    let result = subject
        .nca(&options)
        .map_err(|e| format!("NCA failed: {e}"))?;

    // Compare parameters
    let mut comparisons = Vec::new();

    for (pknca_name, &expected_val) in &expected.parameters {
        let pharmsol_name = map_param_name(pknca_name);

        // Extract pharmsol value based on parameter name
        let pharmsol_val = match pharmsol_name {
            "cmax" => Some(result.exposure.cmax),
            "tmax" => Some(result.exposure.tmax),
            "tlast" => Some(result.exposure.tlast),
            "clast" => Some(result.exposure.clast),
            "auc_last" => Some(result.exposure.auc_last),
            "aumc_last" => result.exposure.aumc_last,
            "auc_inf" | "auc_inf_obs" => result.exposure.auc_inf_obs,
            "auc_inf_pred" => result.exposure.auc_inf_pred,
            "aumc_inf" => result.exposure.aumc_inf,
            "auc_pct_extrap" | "auc_pct_extrap_obs" => result.exposure.auc_pct_extrap_obs,
            "auc_pct_extrap_pred" => result.exposure.auc_pct_extrap_pred,
            "lambda_z" => result.terminal.as_ref().map(|t| t.lambda_z),
            "half_life" => result.terminal.as_ref().map(|t| t.half_life),
            "mrt" => result.terminal.as_ref().and_then(|t| t.mrt),
            "mrt_iv" => result.route_params.as_ref().and_then(|rp| match rp {
                RouteParams::IVInfusion(ref iv) => iv.mrt_iv,
                _ => None,
            }),
            "r_squared" => result
                .terminal
                .as_ref()
                .and_then(|t| t.regression.as_ref())
                .map(|r| r.r_squared),
            "adj_r_squared" => result
                .terminal
                .as_ref()
                .and_then(|t| t.regression.as_ref())
                .map(|r| r.adj_r_squared),
            "n_points" => result
                .terminal
                .as_ref()
                .and_then(|t| t.regression.as_ref())
                .map(|r| r.n_points as f64),
            "span_ratio" => result
                .terminal
                .as_ref()
                .and_then(|t| t.regression.as_ref())
                .map(|r| r.span_ratio),
            "tlag" => result.exposure.tlag,
            "c0" => result.route_params.as_ref().and_then(|rp| match rp {
                RouteParams::IVBolus(ref iv) => Some(iv.c0),
                _ => None,
            }),
            "vd" => result.route_params.as_ref().and_then(|rp| match rp {
                RouteParams::IVBolus(ref iv) => Some(iv.vd),
                _ => None,
            }),
            "vss" => result.clearance.as_ref().and_then(|c| c.vss),
            "cl" | "cl_f" => result.clearance.as_ref().map(|c| c.cl_f),
            "vz" | "vz_f" => result.clearance.as_ref().map(|c| c.vz_f),
            // Steady-state parameters
            "cmin" => result.steady_state.as_ref().map(|ss| ss.cmin),
            "cavg" => result.steady_state.as_ref().map(|ss| ss.cavg),
            "auc_tau" => result.steady_state.as_ref().map(|ss| ss.auc_tau),
            "fluctuation" => result.steady_state.as_ref().map(|ss| ss.fluctuation),
            "swing" => result.steady_state.as_ref().map(|ss| ss.swing),
            _ => None,
        };

        if let Some(pv) = pharmsol_val {
            let matches = approx_eq(pv, expected_val, RELATIVE_TOLERANCE, ABSOLUTE_TOLERANCE);
            comparisons.push((pknca_name.clone(), expected_val, pv, matches));
        }
    }

    Ok(comparisons)
}

// =============================================================================
// Test Entry Point
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    /// Load test scenarios and expected values, run validation
    #[test]
    fn validate_against_pknca() {
        let base_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/pknca_validation");

        // Load scenarios
        let scenarios_path = base_path.join("test_scenarios.json");
        let scenarios_json = fs::read_to_string(&scenarios_path).expect(&format!(
            "Failed to read test_scenarios.json from {:?}",
            scenarios_path
        ));
        let scenarios: TestScenarios =
            serde_json::from_str(&scenarios_json).expect("Failed to parse test_scenarios.json");

        // Try to load expected values (may not exist if R script hasn't been run)
        let expected_path = base_path.join("expected_values.json");
        let expected_values: Option<ExpectedValues> = fs::read_to_string(&expected_path)
            .ok()
            .and_then(|json| serde_json::from_str(&json).ok());

        if expected_values.is_none() {
            println!("\n⚠️  Expected values not found!");
            println!("   Run: cd tests/pknca_validation && Rscript generate_expected.R");
            println!("   Skipping cross-validation tests.\n");
            return;
        }

        let expected = expected_values.unwrap();
        println!("\n═══════════════════════════════════════════════════════════════");
        println!("PKNCA Cross-Validation Results");
        println!("Generated: {}", expected.generated_at);
        println!("PKNCA Version: {}", expected.pknca_version);
        println!("═══════════════════════════════════════════════════════════════\n");

        // Known differences: currently empty - all differences have been resolved!
        // Keeping this infrastructure in case future differences are discovered.
        let known_differences: Vec<(&str, &str, &str)> = vec![];

        let mut total_params = 0;
        let mut passed_params = 0;
        let mut known_diff_params = 0;
        let mut failed_scenarios = Vec::new();

        for scenario in &scenarios.scenarios {
            print!("Testing: {} ... ", scenario.name);

            if let Some(expected_result) = expected.results.get(&scenario.id) {
                match validate_scenario(scenario, expected_result) {
                    Ok(comparisons) => {
                        let mut scenario_passed = 0;
                        let mut scenario_known_diff = 0;
                        let scenario_total = comparisons.len();
                        total_params += scenario_total;

                        let mut failures = Vec::new();
                        let mut known_diffs = Vec::new();

                        for (name, expected_val, actual_val, matched) in &comparisons {
                            if *matched {
                                scenario_passed += 1;
                            } else {
                                // Check if this is a known difference
                                let is_known = known_differences.iter().any(|(sid, pname, _)| {
                                    *sid == scenario.id && *pname == name.as_str()
                                });
                                if is_known {
                                    scenario_known_diff += 1;
                                    let reason = known_differences
                                        .iter()
                                        .find(|(sid, pname, _)| {
                                            *sid == scenario.id && *pname == name.as_str()
                                        })
                                        .map(|(_, _, r)| *r)
                                        .unwrap_or("convention difference");
                                    known_diffs.push((
                                        name.clone(),
                                        *expected_val,
                                        *actual_val,
                                        reason,
                                    ));
                                } else {
                                    failures.push((name.clone(), *expected_val, *actual_val));
                                }
                            }
                        }

                        passed_params += scenario_passed;
                        known_diff_params += scenario_known_diff;

                        if failures.is_empty() {
                            if known_diffs.is_empty() {
                                println!("✓ ({}/{} params)", scenario_passed, scenario_total);
                            } else {
                                println!(
                                    "✓ ({}/{} params, {} known diffs)",
                                    scenario_passed,
                                    scenario_total,
                                    known_diffs.len()
                                );
                                for (name, expected_val, actual_val, reason) in &known_diffs {
                                    println!(
                                        "    [known] {} - expected: {:.6}, got: {:.6} ({})",
                                        name, expected_val, actual_val, reason
                                    );
                                }
                            }
                        } else {
                            println!(
                                "✗ ({}/{} params, {} failures)",
                                scenario_passed,
                                scenario_total,
                                failures.len()
                            );
                            for (name, expected_val, actual_val) in &failures {
                                println!(
                                    "    {} - expected: {:.6}, got: {:.6}",
                                    name, expected_val, actual_val
                                );
                            }
                            if !known_diffs.is_empty() {
                                for (name, expected_val, actual_val, reason) in &known_diffs {
                                    println!(
                                        "    [known] {} - expected: {:.6}, got: {:.6} ({})",
                                        name, expected_val, actual_val, reason
                                    );
                                }
                            }
                            failed_scenarios.push(scenario.id.clone());
                        }
                    }
                    Err(e) => {
                        println!("⚠ {}", e);
                    }
                }
            } else {
                println!("⚠ No expected values");
            }
        }

        println!("\n═══════════════════════════════════════════════════════════════");
        println!(
            "Summary: {}/{} parameters matched ({:.1}%)",
            passed_params,
            total_params,
            (passed_params as f64 / total_params as f64) * 100.0
        );
        if known_diff_params > 0 {
            println!(
                "Known differences: {} (documented convention differences)",
                known_diff_params
            );
        }
        if !failed_scenarios.is_empty() {
            println!("Failed scenarios: {:?}", failed_scenarios);
        }
        println!("═══════════════════════════════════════════════════════════════\n");

        // Fail test only for unexpected failures (not known differences)
        assert!(
            failed_scenarios.is_empty(),
            "Some scenarios failed validation with unexpected differences"
        );
    }

    /// Quick sanity test that runs without PKNCA expected values
    #[test]
    fn basic_nca_sanity_check() {
        // Simple IV bolus test
        let subject = Subject::builder("sanity")
            .bolus(0.0, 100.0, 0)
            .observation(0.0, 10.0, 0)
            .observation(1.0, 6.0, 0)
            .observation(2.0, 3.6, 0)
            .observation(4.0, 1.3, 0)
            .observation(8.0, 0.17, 0)
            .build();

        let options = NCAOptions::default();
        let result = subject.nca(&options).expect("NCA should succeed");

        // Basic sanity checks
        assert_eq!(result.exposure.cmax, 10.0);
        assert_eq!(result.exposure.tmax, 0.0);
        assert!(result.exposure.auc_last > 0.0);
        assert!(result.terminal.is_some());

        let terminal = result.terminal.as_ref().unwrap();
        assert!(terminal.lambda_z > 0.0);
        assert!(terminal.half_life > 0.0);
    }
}
